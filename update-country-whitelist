#!/usr/bin/env python3
"""
Fetch IPv4/IPv6 CIDR whitelists for selected countries and apply them
as nftables sets, replacing a dynamic include file safely and atomically,
with strict parsing/validation to prevent injection of malicious data.
"""

import os
import sys
import logging
import requests
import tempfile
import subprocess
import ipaddress
from pathlib import Path
from textwrap import indent
from typing import List, Tuple, Set

# ----------------------------------------------------------------------
# Configuration
# ----------------------------------------------------------------------

COUNTRIES: List[str] = ["DE", "NL"]

BASE_URL: str = (
    "https://raw.githubusercontent.com/ebrasha/cidr-ip-ranges-by-country/refs/heads/master/CIDR"
)

DEST: Path = Path("/etc/nftables.d/whitelist.nft")
FETCH_TIMEOUT: int = 20

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)

# ----------------------------------------------------------------------
# CIDR parsing
# ----------------------------------------------------------------------

def parse_cidr_lines(lines: List[str]) -> Tuple[Set[str], Set[str]]:
    """
    Parse text lines into validated IPv4 and IPv6 CIDR strings.
    Any line that is not a valid network is ignored.
    """
    ipv4 = set()
    ipv6 = set()
    for lineno, line in enumerate(lines, 1):
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        try:
            net = ipaddress.ip_network(line, strict=False)
        except ValueError:
            logging.warning("Skipping invalid CIDR line %d: %r", lineno, line)
            continue
        if isinstance(net, ipaddress.IPv4Network):
            ipv4.add(str(net))
        else:
            ipv6.add(str(net))
    return ipv4, ipv6

# ----------------------------------------------------------------------
# Fetch and merge country whitelists safely
# ----------------------------------------------------------------------

def fetch_country_cidrs(fetch_timeout: int = FETCH_TIMEOUT) -> Tuple[List[str], List[str]]:
    """Return (ipv4, ipv6) lists for all configured countries, safely parsed."""
    all_ipv4: Set[str] = set()
    all_ipv6: Set[str] = set()

    session = requests.Session()

    for cc in COUNTRIES:
        cc = cc.strip().upper()
        if not cc:
            continue

        for family in ("ipv4", "ipv6"):
            url = f"{BASE_URL}/{cc}-{family}-Hackers.Zone.txt"
            logging.info("Fetching %s %s list...", cc, family)
            try:
                r = session.get(url, timeout=fetch_timeout)
                r.raise_for_status()
            except requests.RequestException as e:
                logging.warning("Failed to fetch %s: %s", url, e)
                continue

            ipv4_list, ipv6_list = parse_cidr_lines(r.text.splitlines())
            all_ipv4 |= ipv4_list
            all_ipv6 |= ipv6_list

    logging.info("Fetched %d IPv4 and %d IPv6 valid CIDRs total.", len(all_ipv4), len(all_ipv6))
    return sorted(all_ipv4), sorted(all_ipv6)

# ----------------------------------------------------------------------
# Nftables file generation and validation
# ----------------------------------------------------------------------

def format_elements_block(cidr_list: List[str], base_indent: int = 8) -> str:
    """Return a nicely formatted nftables 'elements = { ... }' block."""
    if not cidr_list:
        return "elements = {}"
    cidr_indent = base_indent + 4
    inner = ",\n".join(cidr_list)
    return f"elements = {{\n{indent(inner, ' ' * cidr_indent)}\n{' ' * base_indent}}}"

def generate_rule_file(ipv4: List[str], ipv6: List[str]) -> str:
    """Render the nftables include file directly in Python."""
    ipv4_block = format_elements_block(ipv4)
    ipv6_block = format_elements_block(ipv6)
    return f"""table inet whitelist {{
    set allowed_v4 {{
        type ipv4_addr
        flags interval
        {ipv4_block}
    }}

    set allowed_v6 {{
        type ipv6_addr
        flags interval
        {ipv6_block}
    }}

    chain input_filter {{
        type filter hook input priority -10;
        policy accept;

        # Always allow loopback & established connections
        iifname "lo" accept
        ct state established,related accept

        # Allow link-local and multicast IPv6 (RA, ND, DHCPv6, etc.)
        ip6 saddr fe80::/10 accept comment "Allow link-local IPv6 (ND, RA)"
        ip6 saddr ff00::/8 accept comment "Allow IPv6 multicast (ND, RA, DHCPv6)"

        # Allow whitelisted networks
        ip saddr @allowed_v4 accept
        ip6 saddr @allowed_v6 accept

        # Drop everything else
        drop
    }}
}}""".strip() + "\n"

def validate_nftables(temp_path: Path) -> None:
    """Syntax-check the generated nftables rules."""
    logging.info("Testing nftables syntax...")
    try:
        subprocess.run(
            ["nft", "-c", "-f", str(temp_path)],
            check=True,
            capture_output=True,
            text=True,
        )
    except subprocess.CalledProcessError as e:
        logging.error("nftables syntax check failed:\n%s", e.stderr)
        raise RuntimeError("nftables syntax validation failed") from e

def apply_nftables() -> None:
    """Apply nftables configuration to the live system."""
    logging.info("Applying nftables configuration...")
    subprocess.run(["nft", "-f", "/etc/nftables.conf"], check=True)

# ----------------------------------------------------------------------
# Atomic file writing
# ----------------------------------------------------------------------

def write_atomic_file(content: str, directory: Path) -> Path:
    """Write content atomically to a file under directory and return its Path."""
    with tempfile.NamedTemporaryFile("w", dir=directory, suffix=".nft", delete=False) as tmp:
        tmp.write(content)
        tmp.flush()
        os.fsync(tmp.fileno())
        temp_path = Path(tmp.name)
    return temp_path

# ----------------------------------------------------------------------
# Main entry point
# ----------------------------------------------------------------------

def main() -> int:
    try:
        ipv4, ipv6 = fetch_country_cidrs()
        if not ipv4 and not ipv6:
            logging.warning("No CIDRs fetched, aborting update.")
            return 1

        tmp_path = write_atomic_file(generate_rule_file(ipv4, ipv6), DEST.parent)
        validate_nftables(tmp_path)
        tmp_path.replace(DEST)
        apply_nftables()
        logging.info("✅ Whitelist updated successfully.")
        return 0

    except Exception as e:
        logging.exception("❌ Update failed: %s", e)
        return 1

if __name__ == "__main__":
    sys.exit(main())
