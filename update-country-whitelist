#!/usr/bin/env python3
"""
Fetch IPv4/IPv6 CIDR whitelists for selected countries and apply them
as nftables sets, replacing a dynamic include file safely and atomically.
"""

import os
import sys
import logging
import requests
import tempfile
import subprocess
from pathlib import Path
from textwrap import indent
from typing import List, Tuple, Set

COUNTRIES: List[str] = ["DE", "NL"]

BASE_URL: str = (
    "https://raw.githubusercontent.com/ebrasha/cidr-ip-ranges-by-country/refs/heads/master/CIDR"
)

DEST: Path = Path("/etc/nftables.d/whitelist.nft")
FETCH_TIMEOUT: int = 20

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)


def fetch_country_cidrs(fetch_timeout: int = FETCH_TIMEOUT) -> Tuple[List[str], List[str]]:
    """Return (ipv4, ipv6) lists for all configured countries."""
    ipv4: Set[str] = set()
    ipv6: Set[str] = set()

    session = requests.Session()

    for cc in COUNTRIES:
        cc = cc.strip().upper()
        if not cc:
            continue

        for family in ("ipv4", "ipv6"):
            url = f"{BASE_URL}/{cc}-{family}-Hackers.Zone.txt"
            logging.info("Fetching %s %s list...", cc, family)
            try:
                r = session.get(url, timeout=fetch_timeout)
                r.raise_for_status()
            except requests.RequestException as e:
                logging.warning("Failed to fetch %s: %s", url, e)
                continue

            for line in r.text.splitlines():
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                (ipv6 if ":" in line else ipv4).add(line)

    logging.info("Fetched %d IPv4 and %d IPv6 CIDRs total.", len(ipv4), len(ipv6))
    return sorted(ipv4), sorted(ipv6)


def format_elements_block(cidr_list: List[str], base_indent: int = 8) -> str:
    """Return a nicely formatted nftables 'elements = { ... }' block."""
    if not cidr_list:
        return "elements = {}"

    cidr_indent = base_indent + 4
    inner = ",\n".join(cidr_list)
    return f"elements = {{\n{indent(inner, ' ' * cidr_indent)}\n{' ' * base_indent}}}"


def generate_rule_file(ipv4: List[str], ipv6: List[str]) -> str:
    """Render the nftables include file directly in Python."""
    ipv4_block = format_elements_block(ipv4)
    ipv6_block = format_elements_block(ipv6)

    return f"""table inet whitelist {{
    set allowed_v4 {{
        type ipv4_addr
        flags interval
        {ipv4_block}
    }}

    set allowed_v6 {{
        type ipv6_addr
        flags interval
        {ipv6_block}
    }}

    chain input_filter {{
        type filter hook input priority -10;
        policy accept;

        # Always allow loopback & established connections
        iifname "lo" accept
        ct state established,related accept

        # Allow whitelisted networks
        ip saddr @allowed_v4 accept
        ip6 saddr @allowed_v6 accept

        # Drop everything else
        drop
    }}
}}""".strip() + "\n"


def validate_nftables(temp_path: Path) -> None:
    """Syntax-check the generated nftables rules."""
    logging.info("Testing nftables syntax...")
    try:
        subprocess.run(
            ["nft", "-c", "-f", str(temp_path)],
            check=True,
            capture_output=True,
            text=True,
        )
    except subprocess.CalledProcessError as e:
        logging.error("nftables syntax check failed:\n%s", e.stderr)
        raise RuntimeError("nftables syntax validation failed") from e


def apply_nftables() -> None:
    """Apply nftables configuration to the live system."""
    logging.info("Applying nftables configuration...")
    subprocess.run(["nft", "-f", "/etc/nftables.conf"], check=True)


def write_atomic_file(content: str, directory: Path) -> Path:
    """Write content atomically to a file under directory and return its Path."""
    with tempfile.NamedTemporaryFile("w", dir=directory, suffix=".nft", delete=False) as tmp:
        tmp.write(content)
        tmp.flush()
        os.fsync(tmp.fileno())
        temp_path = Path(tmp.name)
    return temp_path


def main() -> int:
    try:
        ipv4, ipv6 = fetch_country_cidrs()
        if not ipv4 and not ipv6:
            logging.warning("No CIDRs fetched, aborting update.")
            return 1

        tmp_path = write_atomic_file(generate_rule_file(ipv4, ipv6), DEST.parent)
        validate_nftables(tmp_path)
        tmp_path.replace(DEST)
        apply_nftables()
        logging.info("✅ Whitelist updated successfully.")
        return 0

    except Exception as e:
        logging.exception("❌ Update failed: %s", e)
        return 1


if __name__ == "__main__":
    sys.exit(main())
